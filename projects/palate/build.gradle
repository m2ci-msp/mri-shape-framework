import FlagBuilder

// create tasks for subprojects
subprojects { subproject ->
    // get right configuration for the subproject
    def config = rootProject.ext.configMap["$subproject.name"]

    task alignPalateTemplate {
        description = "Rigidly aligns the palate template using landmark information."

        def speaker = config.speaker.name
        def scan = config.speaker.scan
        def dataset = config.speaker.dataset

        // source and destination file
        def scanPath = config.speaker.scanPath

        // landmarks
        def landmarkFile = new File(rootProject.buildDir, "$scanPath/landmarksPalate/landmarks.json")
        def alignedTemplate = new File(rootProject.buildDir, "$scanPath/alignPalateTemplate/alignedTemplate.ply")

        // template file
        def templateFile  = new File(templateDir, "${palateTemplateName}.ply")

        // align depends on the landmarksPalate task
        dependsOn "landmarksPalate"

        inputs.file landmarkFile
        outputs.file alignedTemplate

        // read necessary settings


        doLast{
            alignedTemplate.getParentFile().mkdirs()

            logger.debug("landmark-alignment --noRotation --noScaling --source $templateFile --landmarks $landmarkFile --output $alignedTemplate")

            exec{
                commandLine "landmark-alignment --noRotation --noScaling --source $templateFile --landmarks $landmarkFile --output $alignedTemplate".tokenize()
                workingDir rootProject.buildDir
            }
        }
    }

    ///////////////////////////////////////////////////////////////////////////

    task landmarksPalate {

        description = "Computes palate landmarks files usable by the template matching."

        def speaker = config.speaker.name
        def scan = config.speaker.scan
        def dataset = config.speaker.dataset
        def scanPath = config.speaker.scanPath

        // source and destination directories
        def srcFile = file("$landmarksPalateDir/$scanPath/landmarks.json")
        def destFile = file("$rootProject.buildDir/$scanPath/landmarksPalate/landmarks.json")
        def templateLandmarksFile = file("$rootProject.buildDir/landmarksPalate.json")
        def scanFile = file("$mriDir/$scanPath/scan.json")

        // landmarksPalate depends on the createPalateTemplateLandmarks task
        dependsOn rootProject.createPalateTemplateLandmarks

        inputs.files srcFile, templateLandmarksFile, scanFile
        outputs.file destFile

        doLast{

            destFile.parentFile.mkdirs()
            def slurper = new groovy.json.JsonSlurper()

            // open spacings of scan
            def spacings = slurper.parse(scanFile).spacings

            // open template landmarks
            def templateLandmarks = slurper.parse(templateLandmarksFile)

            // open user landmarks
            def userLandmarks = slurper.parse(srcFile)

            // construct landmark correspondences list
            def landmarks = []

            templateLandmarks.each{ mark ->
                def found = userLandmarks.find{
                    it.name == mark.name
                }
                if ( found != null) {
                    // fuse landmark information
                    landmarks << [
                        name: found.name,
                        sourceIndex: mark.index,
                        sourceX : mark.X,
                        sourceY : mark.Y,
                        sourceZ : mark.Z,
                        // scale target positions according to the spacings
                        targetX: found.x.toDouble() * spacings.x.toDouble(),
                        targetY: found.y.toDouble() * spacings.y.toDouble(),
                        targetZ: found.z.toDouble() * spacings.z.toDouble(),
                    ]
                }
            }

            // build json file
            def json = new groovy.json.JsonBuilder(landmarks)

            destFile.withWriter{
                it << json.toPrettyString()
            }

        }
    }

    ///////////////////////////////////////////////////////////////////////////

    task matchPalate {
        description = "Performs template matching for extracting the palate shape."

        def speaker = config.speaker.name
        def scan = config.speaker.scan
        def dataset = config.speaker.dataset
        def scanPath = config.speaker.scanPath

        def pointCloud = file("$rootProject.buildDir/$scanPath/segmentPalate/point_cloud.obj")
        // landmarks, file does not need to exist
        def landmarkFile = file("$rootProject.buildDir/$scanPath/landmarksPalate/landmarks.json")
        def destDir = file("$rootProject.buildDir/$scanPath/matchPalate")

        // template file
        //def templateFile = file("$rootProject.buildDir/$scanPath/alignPalateTemplate/alignedTemplate.ply")
        def templateFile  = new File(templateDir, "${palateTemplateName}.ply")
        // matchPalate depends on the segmentPalate, landmarksPalate, and alignPalateTemplate task

        dependsOn "segmentPalate"
        dependsOn "landmarksPalate"
//        dependsOn "alignPalateTemplate"

        inputs.file pointCloud
        outputs.dir destDir

        doLast{
            destDir.mkdirs()

            // assemble necessary settings
            def flags = (new FlagBuilder()).build(config.speaker.matchPalate)

            flags.add("--source $templateFile")
            flags.add("--target $pointCloud")
            flags.add("--output tracking_org_result0.ply")
            flags.add("--performRigidAlignment")

            if( landmarkFile.exists() ) {
                flags.add("--landmarks $landmarkFile")
            }

            logger.debug("match-template ${flags.join(' ')}")

            exec{
                commandLine "match-template ${flags.join(' ')}".tokenize()
                workingDir destDir
            }
        }
    }

    ///////////////////////////////////////////////////////////////////////////


    task projectMatchedPalate { task ->
        description = "Projects matched palate to scan."

        def speaker = config.speaker.name
        def scan = config.speaker.scan
        def dataset = config.speaker.dataset
        def scanPath = config.speaker.scanPath

        // input
        def aligned = file("$rootProject.buildDir/$scanPath/matchPalate/tracking_org_result0.ply")
        def palateScan = file("$rootProject.buildDir/$scanPath/cropToVocalTract/vocaltract.json")

        // output
        def destDir = file("$rootProject.buildDir/$scanPath/$task.name")

        def projected = file("$destDir/projected.json")


        // projectPalate depends on the matchPalate task
        dependsOn "matchPalate"

        inputs.files aligned, palateScan
        outputs.dir destDir

        doLast{
            destDir.mkdirs()

            def command = "mesh-project --mesh $aligned --scan $palateScan --output $projected"
            logger.debug(command)
            exec{
                commandLine command.tokenize()
                workingDir rootProject.buildDir
            }
        }
    }

    ///////////////////////////////////////////////////////////////////////////

    task estimatePalateThreshold{

        def speaker = config.speaker.name
        def dataset = config.speaker.dataset
        def scan = config.speaker.scan
        def scanPath = config.speaker.scanPath

        def srcFile = file("$rootProject.buildDir/$scanPath/cropToVocalTract/vocaltract.json")
        def landmarkFile = file("$landmarksPalateDir/$scanPath/landmarks.json")
        def outputFile = file("$rootProject.buildDir/$scanPath/estimatePalateThreshold/threshold.json")

        def cropToVocalTract = ":projects:shared:$dataset.name-$speaker-$scan:cropToVocalTract"

        dependsOn cropToVocalTract

        inputs.file srcFile
        inputs.file landmarkFile

        outputs.file outputFile

        doLast{

            outputFile.parentFile.mkdirs()

            def cmd = "estimate-threshold-with-landmarks --images ${srcFile} --landmarks ${landmarkFile} --scale_to_8bit --output $outputFile"

            exec{

                commandLine cmd.tokenize()
                workingDir rootProject.buildDir

            }

        }

    }

    ///////////////////////////////////////////////////////////////////////////

    task segmentPalate { task ->
        description = "Segments a scan by using thresholding. The normals in the point cloud are inverted."

        def speaker = config.speaker.name
        def scan = config.speaker.scan
        def dataset = config.speaker.dataset
        def scanPath = config.speaker.scanPath

        def srcFile = file("$rootProject.buildDir/$scanPath/cropToVocalTract/vocaltract.json")
        def destDir = file("$rootProject.buildDir/$scanPath/$task.name")
        def segmentation = file("$destDir/segmentation.json")
        def cloudFile = file("$destDir/point_cloud.obj")

        // segment depends on the cropToVocalTract task
        def cropToVocalTract = ":projects:shared:$dataset.name-$speaker-$scan:cropToVocalTract"

        dependsOn cropToVocalTract

        // read necessary settings
        def thresholdingType = config.speaker.segmentPalate.thresholdingType


        if(thresholdingType == "WITH LANDMARKS") {

            dependsOn "estimatePalateThreshold"
            inputs.file file("$rootProject.buildDir/$scanPath/estimatePalateThreshold/threshold.json")

        }

        inputs.file srcFile
        outputs.dir destDir

        doLast{
            destDir.mkdirs()


            def command = ""

            switch(thresholdingType) {

                case "BASIC":

                    def threshold = config.speaker.segmentPalate.threshold
                    command = "threshold --input $srcFile --threshold $threshold --scale_to_8bit --output $segmentation --cloud $cloudFile --flip"
                    break

                case "OTSU":

                    command = "otsu-threshold --input $srcFile --output $segmentation --cloud $cloudFile --flip"
                    break

                case "WITH LANDMARKS":

                    def thresholdFile = file("$rootProject.buildDir/$scanPath/estimatePalateThreshold/threshold.json")

                    def threshold = (new groovy.json.JsonSlurper()).parse(thresholdFile).threshold

                    command = "threshold --input $srcFile --threshold $threshold --scale_to_8bit --output $segmentation --cloud $cloudFile --flip"

                    break

                case "WEIGHTED OTSU":

                  def weightInside = config.speaker.segmentPalate.weightInside
                  def weightOutside = config.speaker.segmentPalate.weightOutside

                  command = "weighted-otsu-threshold --input $srcFile --weightInside ${weightInside} --weightOutside ${weightOutside} --output $segmentation --cloud $cloudFile --flip"

                  break

                default:

                    throw new Exception("Unknown thresholding type.")
                    break

            }

            logger.debug(command)
            logging.captureStandardOutput LogLevel.DEBUG

            exec{
                commandLine command.tokenize()
                workingDir rootProject.buildDir
            }
        }
    }

}
